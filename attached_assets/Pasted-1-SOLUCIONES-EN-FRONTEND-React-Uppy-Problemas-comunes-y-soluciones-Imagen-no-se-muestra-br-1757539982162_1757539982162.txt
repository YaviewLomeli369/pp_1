1️⃣ SOLUCIONES EN FRONTEND (React + Uppy)
Problemas comunes y soluciones:

Imagen no se muestra / broken link

<img src={imageUrl} alt="Producto" />


Solución: Asegúrate de usar URL absoluta devuelta por el backend:

const imageUrl = `${window.location.protocol}//${window.location.host}/uploads/${filename}`;
setImageUrl(imageUrl);


React no re-renderiza

Causa: No se actualiza estado

Solución:

setProducts([...products, newProduct]);


Cache del navegador

Solución: Agregar timestamp o hash al nombre de archivo:

const uniqueFilename = `${Date.now()}-${file.name}`;


CSS invisible

Solución: Revisar devtools y ajustar:

img { display: block; max-width: 100%; height: auto; }


Mixed Content (HTTP/HTTPS)

Solución: Generar URL con mismo protocolo:

const url = `${window.location.protocol}//${window.location.host}/uploads/${filename}`;


Uppy no envía imagen

Solución: Configurar correctamente:

const uppy = new Uppy({ autoProceed: true })
  .use(XHRUpload, {
    endpoint: '/api/upload',
    fieldName: 'file',
    headers: { Authorization: `Bearer ${token}` }
  });


Tamaño / tipo de archivo no permitido

.use(Uppy.FileInput, { allowedFileTypes: ['image/*'], maxFileSize: 5*1024*1024 });

2️⃣ SOLUCIONES EN BACKEND (Express + Multer)

Carpeta de uploads no existe

const fs = require('fs');
const uploadPath = './uploads';
if (!fs.existsSync(uploadPath)) fs.mkdirSync(uploadPath, { recursive: true });


Sin permisos

chmod 755 uploads


Archivo sobrescrito

const storage = multer.diskStorage({
  destination: './uploads',
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  }
});


Multer no recibe archivo

Verifica fieldName:

upload.single('file')


Ruta no expuesta (404)

app.use('/uploads', express.static('uploads'));


URL devuelta incorrecta

res.json({ url: `${req.protocol}://${req.get('host')}/uploads/${req.file.filename}` });


CORS

const cors = require('cors');
app.use(cors({ origin: '*' })); // Ajusta origen en producción


Tamaño máximo

const upload = multer({ limits: { fileSize: 5*1024*1024 } });


Token faltante / autorización

Middleware de autenticación:

app.post('/api/upload', authMiddleware, upload.single('file'), (req, res) => {...});

3️⃣ SOLUCIONES DE DEPLOY, HTTPS Y HOST

Mixed Content

Asegurar que la URL use https:// en producción:

const url = `${req.secure ? 'https' : 'http'}://${req.get('host')}/uploads/${file.filename}`;


VPS / Nginx

location /uploads {
    alias /var/www/project/uploads;
}


Docker

volumes:
  - ./uploads:/usr/src/app/uploads


HTTPS certificado inválido

Usar Let's Encrypt y renovar certificado:

sudo certbot --nginx -d example.com

4️⃣ SOLUCIONES DE FORMATO Y COMPATIBILIDAD

Imagen corrupta

Validar tamaño y tipo antes de guardar:

if(!file.mimetype.startsWith('image/')) throw new Error('Solo imágenes permitidas');


Formatear o redimensionar

Usar Sharp para redimensionar:

const sharp = require('sharp');
sharp(req.file.path).resize(800, 800).toFile(`./uploads/resized-${req.file.filename}`);


Transparencia perdida

Mantener formato PNG cuando sea necesario:

sharp(req.file.path).png().toFile(`./uploads/${req.file.filename}`);

5️⃣ SOLUCIONES DE USUARIO / UI

Bloquear tipos no permitidos en el frontend.

Mostrar feedback en UI si upload falla.

Subida múltiple: asegurarse que multiple: true en <input type="file" multiple /> y Uppy.

6️⃣ SOLUCIONES DE SISTEMA / MANTENIMIENTO

Espacio lleno: monitorear disco, limpiar uploads antiguos.

Reinicio del servidor: usar almacenamiento persistente o nube (S3, Cloudinary).

Diferencia Dev/Prod: rutas absolutas en producción, rutas relativas solo en desarrollo.

7️⃣ CHECKLIST DE SOLUCIÓN COMPLETA

Crear carpeta /uploads con permisos correctos.

Configurar Multer correctamente con diskStorage + nombre único.

Validar tipo y tamaño de archivo en frontend y backend.

Configurar CORS y token de autorización si aplica.

Devolver URL absoluta en JSON desde backend.

React: actualizar estado y renderizar imagen correctamente.

Manejar cache añadiendo timestamp al nombre.

HTTPS / Mixed Content: asegurar mismo protocolo.

Redimensionar y mantener formato usando Sharp.

Revisar logs frontend y backend para cualquier error de red o Multer.

En producción, mapear correctamente carpeta en VPS o Docker.

Feedback visual en UI de progreso de subida y errores.