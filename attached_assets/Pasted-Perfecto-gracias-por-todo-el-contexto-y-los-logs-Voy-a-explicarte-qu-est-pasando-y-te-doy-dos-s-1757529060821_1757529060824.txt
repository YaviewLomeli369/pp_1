Perfecto — gracias por todo el contexto y los logs. Voy a explicarte qué está pasando y te doy dos soluciones concretas y completas (una rápida en el frontend y la definitiva en el backend). Aplica ambas si quieres una solución robusta.

¿Qué está pasando (en claro)?

Cuando subes un archivo, tu servidor crea ficheros con nombres diferentes según el flujo de subida. Algunos se guardan con el nombre final incluyendo la extensión (<uuid>-bg.png) y otros con un nombre temporal/sin extensión que contiene .upload-<timestamp> (<uuid>-1757...upload-1757...).

Tu frontend, en algunos cambios anteriores, intentó reconstruir la URL pública como /objects/<objectId>/<originalFilename> — pero en el disco no siempre existe esa ruta. En muchos casos el archivo guardado es exactamente /uploads/<objectName.con.upload-suffix> y NO /uploads/<objectId>/<originalFilename>.

Resultado: el navegador solicita /objects/<algo> y el servidor responde 404 porque la ruta solicitada no coincide con el fichero físico o con la lógica de mapeo del servidor.

En resumen: hay inconsistencia entre el nombre que devuelve el backend y la URL que usa el frontend para mostrar la imagen — y el backend tampoco intenta resolver variantes.

SOLUCIÓN RÁPIDA (frontend) — para que la app deje de romperse ya

Cambia handleUploadComplete para:

usar exactamente el objectName o uploadURL que devuelve el servidor (sin inventar rutas con el nombre original).

almacenar la URL absoluta: https://tu-dominio/objects/<objectName> en la DB / petición PUT.

Reemplaza tu bloque de guardado (en la función handleUploadComplete) por este fragmento (lista para pegar):

// --- Reemplaza la parte final de handleUploadComplete por esto ---
    // Obtener el nombre que devolvió el servidor (si existe)
    const serverBody = (file.response?.body as any) || {};
    // Preferir el campo que te devuelva el servidor: objectName / url / location / uploadURL
    const serverObjectName =
      serverBody.objectName ||
      serverBody.object ||
      // si server devuelve url '/objects/xxx' -> extraer ultimo segmento
      (typeof serverBody.url === "string" ? serverBody.url.split("/").pop() : null) ||
      (typeof serverBody.location === "string" ? serverBody.location.split("/").pop() : null) ||
      null;

    // Si no está objectName, tomar uploadURL tal cual (viene como '/objects/<objectName>')
    let storedObjectSegment = serverObjectName;
    if (!storedObjectSegment) {
      const maybePath = (file.uploadURL || file.response?.uploadURL || file.response?.url || file.response?.location);
      if (typeof maybePath === "string") {
        storedObjectSegment = maybePath.split("/").pop() || maybePath;
      }
    }

    if (!storedObjectSegment) {
      console.error("❌ No se pudo deducir nombre de objeto desde la respuesta:", file.response);
      toast({
        title: "Error al subir imagen",
        description: "No se pudo determinar la ruta del objeto en el servidor",
        variant: "destructive"
      });
      return;
    }

    // Construir URL pública absoluta (guardarla así en DB/PUT)
    const publicUrl = storedObjectSegment.startsWith("http")
      ? storedObjectSegment
      : `${window.location.origin}/objects/${encodeURIComponent(storedObjectSegment)}`;

    console.log("COMPLETE-4. ✅ Public URL a guardar:", publicUrl);

    // Guardar según el caso (producto existente o nuevo)
    if (selectedProduct?.id) {
      updateProductImageMutation.mutate({
        id: selectedProduct.id,
        imageURL: publicUrl,
      });
    } else {
      setTempImageUrl(publicUrl);
      toast({
        title: "Imagen subida exitosamente",
        description: "Se aplicará al guardar el producto",
      });
    }


Por qué esto ayuda ahora: evita reconstrucciones erróneas (como /objects/<id>/<bg.png>) y guarda exactamente lo que el backend dejó en disco. Si el archivo está realmente accesible en /objects/<objectName>, entonces el preview funcionará.

SOLUCIÓN DEFINITIVA (backend) — arreglar el servidor para que resuelva cualquier variante

Idealmente el servidor debería:

devolver siempre la URL final (con nombre y extensión si corresponde) en response.body.url o objectName, y/o

soportar una ruta GET /objects/:objectId/:filename? que busque en el disco el fichero físico correspondiente (sea objectId-<originalName> o objectId.upload-<timestamp> o objectId-...) y lo sirva.

A continuación te dejo un handler Express que puedes añadir (por ejemplo) en server/objectStorage.ts o server/index.ts antes de servir la carpeta estática. Este handler hace una búsqueda inteligente en la carpeta uploads y devuelve el primer match razonable:

// --- Añade esto en tu servidor (express) donde configures routes/static ---
// Ajusta uploadsDir según tu estructura real
import path from "path";
import fs from "fs/promises";
import { existsSync } from "fs";

// uploadsDir: ruta absoluta al directorio uploads. Ej: path.join(__dirname, '..', 'uploads')
const uploadsDir = path.resolve(process.cwd(), "uploads");

app.get("/objects/:objectId/:maybeFilename?", async (req, res) => {
  try {
    const { objectId, maybeFilename } = req.params;
    // Leer ficheros de uploads (puede ser lento si hay muchos; puedes optimizar con cache)
    const files = await fs.readdir(uploadsDir);

    // 1) Si nos pidieron /objects/<fullName> (objectId incluye puntos), tratarlo como nombre completo
    //    (esto sucede cuando frontend usa /objects/<objectName-with-dot>)
    if (!maybeFilename) {
      // buscar archivo que EXACTAMENTE coincida con objectId
      let match = files.find(f => f === objectId);
      if (!match) {
        // buscar archivos que comiencen por el objectId-  (ej: objectId-originalname.ext)
        match = files.find(f => f.startsWith(`${objectId}-`) || f.startsWith(`${objectId}`));
      }
      if (!match) {
        return res.status(404).send("Not found");
      }
      const filePath = path.join(uploadsDir, match);
      if (!existsSync(filePath)) return res.status(404).send("Not found");
      return res.sendFile(filePath);
    }

    // 2) Si pedimos /objects/:objectId/:filename -> intentamos resolver variantes
    //    candidate: objectId-filename, objectId.filename, objectId-upload..., etc.
    const candidate1 = `${objectId}-${maybeFilename}`;
    const candidate2 = `${objectId}${maybeFilename.startsWith(".") ? "" : "-"}${maybeFilename}`;
    const candidateExact = `${maybeFilename}`; // por si frontend mandó nombre completo luego
    const candidates = [candidate1, candidate2, candidateExact];

    // Tambien aceptar archivos que contengan objectId (por ejemplo objectId-...upload-...)
    let match = files.find(f => candidates.includes(f));
    if (!match) {
      match = files.find(f => f.startsWith(`${objectId}-`) && f.endsWith(path.extname(maybeFilename)));
    }
    if (!match) {
      // fallback: any file that starts with objectId
      match = files.find(f => f.startsWith(objectId));
    }

    if (!match) return res.status(404).send("Not found");

    const filePath = path.join(uploadsDir, match);
    if (!existsSync(filePath)) return res.status(404).send("Not found");
    return res.sendFile(filePath);
  } catch (err) {
    console.error("Error serving object:", err);
    return res.status(500).send("Internal error");
  }
});


Qué hace este handler:

si visitas /objects/<segment> intenta encontrar un archivo en uploads que coincida exactamente o que comience con ese segmento; sirve el primer match.

si visitas /objects/<id>/<filename> intenta reconstruir id-filename o busca cualquier archivo que empiece por id- y termine con la misma extensión.

es robusto frente a que el backend almacene el nombre con o sin .upload-....

Nota de rendimiento: fs.readdir puede ser lento si tienes miles de archivos. Para producción te recomiendo:

mantener estructura de subdirectorios por fecha o por id prefix;

o construir un pequeño índice en memoria al arrancar (cache) y escuchar cambios si necesitas en caliente.

Tests que debes ejecutar (pasos concretos)

Aplica el cambio del frontend (fragmento handleUploadComplete) y sube una imagen. Observa el PUT a /api/store/products/<id> en Network: en el body images debe venir https://<tu-host>/objects/<objectName> (URL absoluta).

Si aún 404: añade el handler backend que te propuse y reinicia server. Vuelve a pedir la URL desde el navegador (o curl -I https://tu-dominio/objects/<objectName>).

En shell (VPS), ejecuta:

ls -l uploads | grep <objectName> para confirmar existencia.

curl -I https://tu-dominio/objects/<objectName> para comprobar HTTP 200 y Content-Type.

Si curl devuelve 404 pero ls muestra el fichero -> revisa permisos (owner/read) y logs de nginx/express.

Resumen / Recomendación final

Fix rápido (frontend): guarda la URL pública exacta que te devuelva el backend (uploadURL / objectName) y hazla absoluta. (Te di el snippet para pegar). Esto evita reconstrucciones erróneas.

Fix definitivo (backend): añade la ruta inteligente /objects/:objectId/:maybeFilename? para resolver automáticamente cualquiera de las variantes de nombre que se crean y servir el fichero correcto. (Código arriba listo para pegar).

A la larga: haz que el endpoint de subida (/api/objects/upload) devuelva el nombre final y estable del objeto (con su extensión) para que el frontend pueda guardarlo sin ambigüedad.

Si quieres, hago una de estas dos cosas ahora mismo (elige una):

Te devuelvo el patch completo (diff) para pegar en tu frontend (AdminStoreContent) — ya he mostrado el snippet a integrar, pero puedo devolverte el archivo completo modificado si quieres.

Te devuelvo el fragmento exacto listo para pegar dentro de server/objectStorage.ts (si me confirmas que usas Express y me indicas la ruta al archivo, lo dejo con las rutas exactas y path.resolve).

Dime cuál prefieres y lo coloco ya listo para aplicar.

Tú dijiste: