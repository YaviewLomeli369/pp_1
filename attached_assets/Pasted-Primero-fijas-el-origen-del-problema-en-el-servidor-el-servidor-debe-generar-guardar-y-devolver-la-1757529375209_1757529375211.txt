Primero fijas el origen del problema en el servidor (el servidor debe generar, guardar y devolver la URL pública final con la extensión correcta). Luego ajustás el frontend para usar exactamente esa URL (sin “reconstrucciones” peligrosas). Finalmente, si tenés archivos ya subidos con nombres “rotos” (sin extensión / con sufijos .upload-*), podés ejecutar un script que detecte el tipo y les añada la extensión correcta.

Abajo tenés todo listo para pegar:

1) Backend — server/objectStorage.ts (o crea/reescribe un archivo nuevo)

Este handler:

genera objectName con la extensión (si el cliente le pasa filename),

devuelve url y uploadURL listos para usar,

atiende los PUT /objects/:name que Uppy/cliente hará,

sirve /objects/* desde la carpeta uploads.

Pega esto (ajustá rutas si tu proyecto tiene otra estructura):

// server/objectStorage.ts
import express from "express";
import fs from "fs";
import path from "path";
import { v4 as uuidv4 } from "uuid";

const router = express.Router();

// Carpeta donde se almacenan archivos públicamente
const uploadsDir = path.join(__dirname, "../uploads");
if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });

// POST /api/objects/upload
// Recibe { filename } y devuelve uploadURL + url pública (con extensión)
router.post("/api/objects/upload", express.json(), (req, res) => {
  try {
    const { filename } = (req.body || {}) as { filename?: string };
    const ext = filename ? path.extname(String(filename)) : "";
    // Generar nombre único conservando extensión si existe
    const objectName = `${uuidv4()}-${Date.now()}${ext}`;
    // URL relativa pública (servida por express.static más abajo)
    const relativeUrl = `/objects/${objectName}`;
    const uploadURL = `${req.protocol}://${req.get("host")}${relativeUrl}`;

    return res.json({
      success: true,
      objectName,
      url: relativeUrl,
      uploadURL,
      location: relativeUrl,
    });
  } catch (err) {
    console.error("Error generating upload params:", err);
    return res.status(500).json({ success: false, error: "Server error" });
  }
});

// PUT /objects/:name  <- Uppy hará PUT directo aquí
router.put("/objects/:name", (req, res) => {
  const name = req.params.name;
  const destPath = path.join(uploadsDir, name);

  // Seguridad mínima: rechazar rutas con .. o que intenten escapar
  if (name.includes("..") || path.isAbsolute(name)) {
    return res.status(400).json({ success: false, error: "Invalid name" });
  }

  const writeStream = fs.createWriteStream(destPath);
  req.pipe(writeStream);

  req.on("end", () => {
    return res.status(200).json({
      success: true,
      objectName: name,
      url: `/objects/${name}`,
      location: `/objects/${name}`,
    });
  });

  req.on("error", (err) => {
    console.error("PUT write error:", err);
    return res.status(500).json({ success: false, error: "Write failed" });
  });
});

// Servir archivos: /objects/<objectName> -> uploads/<objectName>
router.use("/objects", express.static(uploadsDir, { dotfiles: "deny", index: false }));

export default router;


Qué hacer:

Importá/use este router en tu server/index.ts o donde armes rutas (ej.: app.use('/', objectStorageRouter)).

Reiniciá el servidor.

2) Frontend — pedir upload params incluyendo filename y usar uploadURL tal cual

Cambia la función que pide POST /api/objects/upload para enviar el nombre real del archivo y recibir uploadURL final.

Ejemplo para Uppy (o la función que uses):

// handleGetUploadParameters(file)
const handleGetUploadParameters = async (file: { name: string }) => {
  try {
    const response = await apiRequest("/api/objects/upload", {
      method: "POST",
      body: JSON.stringify({ filename: file.name }),
      headers: { "Content-Type": "application/json" },
    });
    // response.uploadURL ya es la URL pública con la extensión
    return {
      method: "PUT" as const,
      url: response.uploadURL,
    };
  } catch (error) {
    toast({ title: "Error", description: "Error al obtener URL de carga", variant: "destructive" });
    throw error;
  }
};


Y en handleUploadComplete: usa exactamente el valor que te devuelve el servidor (file.response.body.url || file.uploadURL) y si es relativa, conviértela a absoluta antes de guardarla/mostrarla:

// small snippet inside handleUploadComplete after obtener imageURL
let finalURL = imageURL.trim();
// si es relativa (/objects/...) convertir a absoluta para <img src="">
if (finalURL.startsWith("/")) {
  finalURL = `${window.location.origin}${finalURL}`;
}
// ahora guardá finalURL en DB o usalo en <img src={finalURL}>


Importante: no intentes reconstruir /objects/<id>/<name> a menos que tu backend lo haga exactamente así. Con el backend propuesto, el archivo queda guardado como uploads/<objectName> y la URL pública es /objects/<objectName> (único nivel).

3) Script opcional para reparar archivos ya existentes sin extensión

Si en uploads/ tenés muchos archivos con sufijo *.upload-xxxxx o sin extensión, podés intentar detectar el tipo y renombrar (añadir extensión). Esto no siempre es 100% seguro, pero ayuda.

Requisitos: instalar file-type (detecta MIME por magic bytes):

npm install file-type


Script scripts/fix-uploads-add-ext.ts (Node.js, Typescript/JS adaptable):

// scripts/fix-uploads-add-ext.ts
import fs from "fs";
import path from "path";
import { fileTypeFromFile } from "file-type";

const uploadsDir = path.join(__dirname, "../uploads");

async function main() {
  const files = fs.readdirSync(uploadsDir);
  const mapping: Array<{ oldName: string; newName: string }> = [];

  for (const f of files) {
    const full = path.join(uploadsDir, f);

    // omit directories
    if (!fs.statSync(full).isFile()) continue;

    // skip if already has an extension that looks OK
    const ext = path.extname(f);
    if (ext && ext.length <= 6 && !f.endsWith(".upload")) {
      console.log("Skip (has ext):", f);
      continue;
    }

    try {
      const ft = await fileTypeFromFile(full);
      if (ft && ft.ext) {
        const newName = `${f}.${ft.ext}`;
        const newPath = path.join(uploadsDir, newName);
        if (!fs.existsSync(newPath)) {
          fs.renameSync(full, newPath);
          mapping.push({ oldName: f, newName });
          console.log("Renamed", f, "->", newName);
        } else {
          console.warn("Target exists, skip:", newName);
        }
      } else {
        console.warn("No mime detected for", f);
      }
    } catch (err) {
      console.error("Error checking file", f, err);
    }
  }

  // Save mapping
  fs.writeFileSync(path.join(uploadsDir, "fix-upload-mapping.json"), JSON.stringify(mapping, null, 2));
  console.log("Done. Mapping saved to fix-upload-mapping.json");
}

main().catch(e => { console.error(e); process.exit(1); });


Uso:

# compilar y ejecutar o con ts-node
npx ts-node scripts/fix-uploads-add-ext.ts


Advertencia:

Revisá el fix-upload-mapping.json. Si la app DB referenciaba /objects/oldName deberás actualizar registros en tu base de datos (o mantener redirecciones).

Alternativa sin rename: dejá los archivos en su nombre actual y ajustá la DB a apuntar a /objects/<oldName> (si el archivo existe). Pero si falta la extensión, el browser igual mostrará si Content-Type se envía correctamente por express.static. Por eso prefiero que el servidor guarde con extensión desde el inicio.

4) Pasos recomendados concretos (en orden)

Implementá y desplegá el router objectStorage.ts en tu servidor y reiniciá la app.

En frontend, ajustá getUploadParameters (o la llamada POST) para enviar filename y recibir uploadURL.

Ajustá handleUploadComplete para usar file.response.body.url || file.uploadURL y, si empieza con /, anteponer window.location.origin.

Hacé una prueba: subí bg.png y verificá que:

Server guarda uploads/<uuid>-<timestamp>.png

Server responde { url: '/objects/<thatname>.png', uploadURL: 'https://host/objects/<thatname>.png' }

Frontend recibe la URL y la usa tal cual; el <img src="..."> carga OK.

(Opcional) Ejecutá el script fix-uploads-add-ext.ts para arreglar archivos ya en uploads/.